#include <math.h>
#include <stdlib.h>
#include <stdio.h>

// #define NSTR_FAKE_NAN 0x7fff
#define MASK_FAKE_NAN (0x7fffUL << 48)
// ^ This uses not 11 but 15 bits all-set. So that only one out of the huge
// number of real NaNs possible with ieee754 is taken up to be used as a flag
// that says whether this numstr is a double or char*. It means usual NaNs
// including those generated by FPEs should be recognized as NaNs and not
// tagged ptrs.

// Note that DataFrames generally need strings as well (non-numeric) since col
// values can be strings sometimes. Maybe have two MASK_FAKE_NAN_NUM and
// MASK_FAKE_NAN_STR taking up 14 / 15 bits resp. so that you can distinguish.
// Then you need a getv and getc (or getNum and getStr) func instead of just
// one get. The user needs to know which col is which btw, not your job.

#define MASK_LOWER48 0xffffffffffffUL
// ^ char* is aligned to 1byte, so you cannot use the lower 2/3 bits for
// anything else. For object ptrs that are usually aligned to 8 or 16B you
// can get a few bits on the lower end for special use.

// typedef union {
//     char* str;
//     double num;
//     struct {
//         long long //
//             _ptr : 48, // unused (this is the ptr value btw)
//             // _extra : 4, // find something creative to put here
//             _nanbitsandmore : 15, // exponent bits
//             _signbit : 1; // don't need the top 11 bits

//         // for a char*, nanbitsandmore == 0x7fff.
//         // i.e. they are all bits set. This is a PARTICULAR case of nan.
//         // so when isnan(f), f is REALLY nan unless this is 0x7fff.
//         // for a double, everything else.
//     };
// } numstr_st;
// ^^ NO MORE BITFIELDS!!

typedef unsigned long long numstr; // uintptr_t to be precise

double dg = 0;
// in-place convert the numstr passed in. That's why you need the pointer.
// otherwise numstrs should generally be passed around by value (size is 8B).
double strtodd(char* s, char* d) { return dg; }

// has this numstr been converted to double?
int numstr_done(numstr ns) { return ((ns & MASK_FAKE_NAN) != MASK_FAKE_NAN); }

// set the double value into this numstr
void numstr_setv(numstr* ns, double d) { *ns = *(numstr*)&d; }

// get the double value from this numstr, converting if needed
double numstr_get(numstr* ns) {
    // turns out this IF comparison will never hold and the compiler will
    // optimise it out (and the body as well). JUST DON'T USE BITFIELDS MAN!
    // if (ns->_nanbitsandmore == NSTR_FAKE_NAN)

    if (!numstr_done(*ns)) //{
        numstr_setv(ns, strtodd((char*)(*ns & MASK_LOWER48), NULL));
    // double d = strtod((char*)ns | MASK_LOWER48, NULL);
    // }

    // ns->num = strtod((char*)ns->_ptr, NULL);
    return *(double*)ns; // ns->num;
}

// set a char* pointing to a numeric string into this numstr
void numstr_setc(numstr* ns, char* s) { *ns = (numstr)s | MASK_FAKE_NAN; }

// ns->str = s;
// ns->_nanbitsandmore = NSTR_FAKE_NAN;
// bitfields generate terrible asm even on O3. Don't use them ever again!
// ns->str = (char*)((unsigned long long)s | MASK_FAKE_NAN);

// isnan is not enough to say whether the number is really nan. It means there
// might be a tagged pointer in the bits, or the number is really null.
// Pointers don't use anything above bit 47 (that's the assumption) so if you
// fill _extra, that could be a flag for real nan
int numstr_isnan(numstr* ns) {
    return isnan(numstr_get(ns)) && numstr_done(*ns);
}
//(ns._nanbitsandmore != NSTR_FAKE_NAN);
// return isnan(ns.num) && (ns._nanbitsandmore != NSTR_FAKE_NAN);

// static const char* st =` "3.14159e21";
int main(int argc, char* argv[]) {
    double d = 0, b;
    long n = atoi(argv[2]);
    long long u = 0;
    numstr* arr = malloc(sizeof(numstr) * n); //[n][n];
    numstr* arrn = arr + n;
    dg = strtod(argv[1], NULL);
    for (int i = 0; i < n; i++) {
        // for (numstr* ai = arr; ai < arrn; ai++) {
        // for (int j = 0; j < n; j++) {
        numstr_setc(&arr[i], argv[1]);
        // numstr_setv(&arr[i], 0.0001e-2);
        // numstr_setc(ai, argv[1]);
        d += numstr_get(&arr[i]);
        // d += numstr_get(ai);
        // d += numstr_get(&arr[i]);
        // u |= (long long)(numstr_get(&arr[i]));
        // u |= (long long)arr[i].num;
        // d += ai->num;
    }
    printf("%lld %f ", u, d);
}