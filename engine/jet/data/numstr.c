#include <math.h>
#include <stdlib.h>
#include <stdio.h>

// #define NSTR_FAKE_NAN 0x7fff
#define MASK_FAKE_NAN (0x7fffUL << 48)
// ^ This uses not 11 but 15 bits all-set. So that only one out of the huge
// number of real NaNs possible with ieee754 is taken up to be used as a flag
// that says whether this numstr_t is a double or char*. It means usual NaNs
// including those generated by FPEs should be recognized as NaNs and not
// tagged ptrs.

// Note that DataFrames generally need strings as well (non-numeric) since col
// values can be strings sometimes. Maybe have two MASK_FAKE_NAN_NUM and
// MASK_FAKE_NAN_STR taking up 14 / 15 bits resp. so that you can distinguish.
// Then you need a getv and getc (or getNum and getStr) func instead of just
// one get. The user needs to know which col is which btw, not your job.

#define MASK_LOWER48 0xffffffffffffUL
// ^ char* is aligned to 1byte, so you cannot use the lower 2/3 bits for
// anything else. For object ptrs that are usually aligned to 8 or 16B you
// can get a few bits on the lower end for special use.

typedef unsigned long long numstr_t; // uintptr_t to be precise

double dg = 0;
// in-place convert the numstr_t passed in. That's why you need the pointer.
// otherwise numstrs should generally be passed around by value (size is 8B).
double strtodd(char* s, char* d) { return dg; }

// has this numstr_t been converted to double?
int numstr_done(numstr_t ns) { return ((ns & MASK_FAKE_NAN) != MASK_FAKE_NAN); }

// set the double value into this numstr_t
void numstr_setv(numstr_t* ns, double d) { *ns = *(numstr_t*)&d; }

// get the double value from this numstr_t, converting if needed
double numstr_get(numstr_t* ns) {
    // turns out this IF comparison will never hold and the compiler will
    // optimise it out (and the body as well). JUST DON'T USE BITFIELDS MAN!
    if (!numstr_done(*ns))
        numstr_setv(ns, strtodd((char*)(*ns & MASK_LOWER48), NULL));
    return *(double*)ns;
}

// set a char* pointing to a numeric string into this numstr_t
void numstr_setc(numstr_t* ns, char* s) { *ns = (numstr_t)s | MASK_FAKE_NAN; }

// ns->str = s;
// ns->_nanbitsandmore = NSTR_FAKE_NAN;
// bitfields generate terrible asm even on O3. Don't use them ever again!
// ns->str = (char*)((unsigned long long)s | MASK_FAKE_NAN);

// isnan is not enough to say whether the number is really nan. It means there
// might be a tagged pointer in the bits, or the number is really null.
// Pointers don't use anything above bit 47 (that's the assumption) so if you
// fill _extra, that could be a flag for real nan
int numstr_isnan(numstr_t* ns) {
    return isnan(numstr_get(ns)) && numstr_done(*ns);
}
//(ns._nanbitsandmore != NSTR_FAKE_NAN);
// return isnan(ns.num) && (ns._nanbitsandmore != NSTR_FAKE_NAN);

// static const char* st =` "3.14159e21";
int main(int argc, char* argv[]) {
    double d = 0, b;
    long n = atoi(argv[2]);
    long long u = 0;
    numstr_t* arr = malloc(sizeof(numstr_t) * n);
    numstr_t* arrn = arr + n;
    dg = strtod(argv[1], NULL);
    for (int i = 0; i < n; i++) {
        numstr_setc(&arr[i], argv[1]);
        d += numstr_get(&arr[i]);
    }
    printf("%lld %f ", u, d);
}