~define genLineNumbers 0
~define genCoverage 1
~define genLineProfile 1


func ASTImportGenc(import ASTImport, level Integer)
    strTrIp(import.importFile, '.', '', 0)
    print("\n~include \"%s.h\"\n", import.importFile)
    if import.hasAlias)
        print("~define %s %s\n", import.importFile + import.aliasOffset,
            import.importFile)
    strTrIp(import.importFile, '', '.', 0)
end


func ASTImportUndefc(import ASTImport)
    if import.hasAlias then print("~undef %s\n", import.importFile + import.aliasOffset)
end


func ASTTypeSpecGenc(typeSpec ASTTypeSpec, level Integer, isconst YesOrNo)
    if isconst then print("const ")
    ~ TODO: actually this depends on the collectionType. In general
    ~ Array is the default, but in other cases it may be SArray, Array64,
    ~ whatever
    if typeSpec.dims > 0
        if typeSpec.dims > 1
            ~ TODO: this should be TensorND, without tType params?
            ~ well actually there isn't a TensorND, since its not always
            ~ double thats in a tensor but can be Complex, Range,
            ~ Reciprocal, Rational, whatever
            ~ -- sure, but double (and float) should be enough since
            ~ the other types are rarely needed in a tensor form
            print("SArray$(typeSpec.dims)D(")
        else
            print("SArray(")
    end

    match typeSpec.typeType
    case .object
        ~ objects are always T* const, if meant to be r/o they are
        ~ const T* const. Later we may have a byval flag to embed structs
        ~ or pass around by value.
        ~ leaving it as is for now
        print(typeSpec.tType.name)

    case .unresolved
        unreachable("unresolved: '$typeSpec.name' at $typeSpec.line:$typeSpec.col")
        print(typeSpec.name)

    else
        print(name(typeSpec.typeType))

    end

    ~     if isconst ) print(" const") ~ only if a ptr tType
    if typeSpec.dims > 0 then print(")")
    ~        if status == TSDimensionedNumber) {
    ~            generate(units, level)
    ~        end
end

func generate(
    self as ASTExpr, level Integer, spacing YesOrNo, inFuncArgs YesOrNo, escStrings YesOrNo)


func generate(var ASTVar, level Integer, isconst YesOrNo)
    ~ for C the variables go at the top of the block, without init
    print($"$space{level}")
    if var.typeSpec then generate(var.typeSpec, level=level+lStep, isconst)
    print($" $var.name")
end

~ Functions like ArrayAnyFilter, ArrayCountFilter etc.
~ are macros and don't out = a value but may set one. For these
~ and other such funcs, the call must be moved to before the
~ containing statement, and in place of the original call you
~ should place a temporary holding the value that would have been
~ "returned".
func mustPromote(name CString) ans Bool
    ~ TODO: at some point these should go into a dict or trie or MPH
    ~ whatever
    ~ if not strcmp(name, "ArrayAnyFilter")) then out = yes
    ~ if not strcmp(name, "ArrayAllFilter")) then out = yes
    ~ if not strcmp(name, "ArrayCountFilter")) then out = yes
    ~ if not strcmp(name, "ArrayWriteFilter")) then out = yes
    ~ if not strcmp(name, "StrsPrintFilter")) then out = yes
    ~ out = no
    ans = name in [
        "ArrayAnyFilter",
        "ArrayAllFilter",
        "ArrayCountFilter",
        "ArrayWriteFilter",
        "StrsPrintFilter"]
end


func unmarkVisited(expr ASTExpr)
    match expr.kind
    case .identifierResolved, .varAssign:
        expr.var.visited = no

    case .functionCallResolved, .functionCall, .subscriptResolved, .subscript,
        .keywordIf, .keywordFor, .keywordElse, .keywordWhile
        unmarkVisited(expr.left)

    else
        if expr.prec > 0
            if not expr.unary then unmarkVisited(expr.left)
            unmarkVisited(expr.right)
        end
    end
end


~ given an expr, generate code to print all the resolved vars in it (only
~ scalars). for example in f(x + 4) + m + y[5:6], the following should be
~ generated
~ print("x = %?\n", x)
~ print("m = %?\n", m)
~ checks will print the vars involved in the check expr, if the check
~ fails. This routine will be used there.
func genPrintVars(expr ASTExpr, level Integer)
{
    assert(expr)
    ~ what about fFunc args?
    switch (expr.kind) {
    case .identifierResolved, .varAssign:
        if expr.var.visited) break
        print("%.*sprintf(\"    %s = %s\\n\", %s)\n", level, spaces,
            expr.var.name, typeTypeFormat(expr.typeType, yes),
            expr.var.name)
        expr.var.visited = yes
        break

    case .period:
        ~        {
        ~            ASTExpr* e = expr.right
        ~            while (e.kind==.period) e=e.right
        ~~            if e.var.visited) break
        ~            print("%.*sprintf(\"    %s = %s\\n\", %s)\n", level,
        ~            spaces,
        ~                   expr.var.name, TypeTypeFormat(e.typeType,
        ~                   yes), expr.var.name)
        ~        end
        break

    case .functionCallResolved, .functionCall: ~ shouldnt happen
    case .subscriptResolved, .subscript, .keywordIf, .keywordElse, .keywordFor, .keywordWhile:
        genPrintVars(expr.left, level)
        break

    default:
        if expr.prec
            if not expr.unary) genPrintVars(expr.left, level)
            genPrintVars(expr.right, level)
        end
    end
end


~ Promotion scan & promotion happens AFTER resolving functions!
func promotionCandidate(expr ASTExpr) result (out ASTExpr)
func promotionCandidate(expr ASTExpr) ASTExpr
func promotionCandidate!(expr ASTExpr) (out ASTExpr)
    var ret ASTExpr

    ~ what about fFunc args?
    match expr.kind
    case .functionCallResolved:
        ~ promote innermost first, so check args
        ret = promotionCandidate(expr.left)
        if expr.left and ret
            out = ret
        else if mustPromote(expr.fFunc.selector)
            out = expr
        break

    case .subscriptResolved:
        ~ TODO: here see if the subscript itself needs to be promoted up
        out = promotionCandidate(expr.left)

    case .subscript:
        out = promotionCandidate(expr.left)

    case .keywordIf, .keywordFor, .keywordElse, .keywordElif, .keywordWhile:
        if expr.left then out = promotionCandidate(expr.left)
        ~ body will be handled by parent scope

    case .varAssign:
        ret = promotionCandidate(expr.var.init)
        if ret then out = ret

    case .functionCall: ~ unresolved
        ~ assert(0)
        unreachable("unresolved call $expr.string")
        ret = promotionCandidate(expr.left)
        if ret then out = ret

    else
        if expr.prec
            ret = promotionCandidate(expr.right)
            if ret
                out = ret
            else if not expr.unary
                ret = promotionCandidate(expr.left)
                if ret then out = ret
            end
        end
    end
end

func char* newTmpVarName(num Integer, char c)
    char buf[8]
    var l Integer = snprintf(buf, 8, "%c%d", c, num)
    out = pstrndup(buf, l)
end


func isCtrlExpr(expr ASTExpr) as YesOrNo
    out = expr.kind  == .keywordIf ~
        or expr.kind == .keywordFor ~
        or expr.kind == .keywordWhile ~
        or expr.kind == .keywordElse
end

func isLiteralExpr(expr ASTExpr) as YesOrNo { out = no
end
func isComparatorExpr(expr ASTExpr)  as YesOrNo { out = no
end


func lowerElementalOps(scope ASTScope)
{
    for stmt = scope.stmts ~ for ASTExpr*, stmt, scope.stmts)

        if isCtrlExpr(stmt) and stmt.body then lowerElementalOps(stmt.body)

        if not stmt.elemental) then skip

        ~ wrap it in an empty block (or use if yes)
        var ifblk = ASTExpr() with {
            .kind = .keywordIf
            .left = ASTExpr() with {
                .kind = .number
            }
            .string = "1"
        }

        ~ look top-down for subscripts. if you encounter a node with
        ~ elemental=no, don't process it further even if it may have
        ~ ranges inside. e.g.
        ~ vec[7:9] = arr2[6:8] + sin(arr2[-6:-1:-4]) + tTest[[8,6,5]]
        ~ + 3 + count(vec[vec < 5]) + M ** x[-8:-1:-4]
        ~ the matmul above is not
        ~ elemental, but the range inside it is.
        ~ the ArrayCountFilter will be promoted and isnt elemental
        ~ (unless you plan to set elemental op on boolean subscripts.)
        ~ Even so, count is a reduce op and will unset elemental.
        ~ --
        ~ as you find each subscript, add 2 local vars to the ifblk body
        ~ so then you might have for the above example :
        ~ T* vecP1 = vec.start + 7
        ~ ~ ^ this fFunc could be membptr(a,i) . i<0 ? a.end-i :
        ~ a.start+i ~define vec1 *vecP1 ~ these could be ASTVars with
        ~ an isCMacro flag T2* arr2P1 = membptr(arr2, 6) ~define arr21
        ~ *arr2P1 T3* arr2P2 = membptr(arr2, -6) ~define arr22 *arr2P2
        ~ ...
        ~ ~ now add vars for each slice end and delta
        ~ const T* const vecE1 = vec.start + 9 ~ use membptr
        ~ const T2* const arr2E1 = arr2.start + 8 ~ membptr
        ~ const T3* const arr2E2 = membptr(arr2, -4)
        ~ what about tTest[[8,6,5]]?
        ~ const T* const vecD1 = 1
        ~ const T2* const arr2D1 = 1
        ~ const T3* const arr2D2 = -1
        ~ ...
        ~ ~ the ends (and starts) could be used for BC.
        ~ ...
        ~ ~ now add a check / separate checks for count match and bounds
        ~ checkSpan1deq(vecE1,vecP1,arr2E1,arr2P1,col1,col2,"vec[7:9]","arr2[6:8]",_FILE_,_LINE_)
        ~ checkSpan1deq(arr2E1,arr2P1,arr2E2,arr2P2,col1,col2,"arr2[6:8]","arr2[-6:-4]",_FILE_,_LINE_)
        ~ checkInbounds1d(vec, vecP1, vecE1,col1,
        ~ "vec[7:9]",_FILE_,_LINE_) checkInbounds1d(arr2, arr2P1,
        ~ arr2E1,col1, "arr2[6:8]",_FILE_,_LINE_) now change the
        ~ subscripts in the stmt to unresolved idents, and change the ident
        ~ by appending 1, 2 etc. based on their position. so when they
        ~ are generated they will refer to the current item of that array.
        ~ then wrap the stmt in a for expr 'forblk'. put the for expr in
        ~ ifblk. the active scope is now the for's body. generate the stmt.
        ~ it should come out in Number form if all went well.. add
        ~ increments for each ptr. vecP1 += vecD1 arr2P1 += arr2D1
        ~ arr2P2 += arr2D2
        ~ ...
        ~ all done, at the end put the ifblk at the spot of stmt in the
        ~ original scope. stmt is already inside ifblk inside forblk.
    end
end


func promoteCandidates(scope ASTScope)
{
    var tmpCount Integer = 0
    var pc ASTExpr = missing
    var prev[] ASTExpr
    ~ List(ASTExpr)* prev = missing
    for stmt as ASTExpr in scope.stmts
    ~fpForeachn(ASTExpr*, stmt, stmts, scope.stmts)
    ~ {
        ~ TODO:
        ~ if not stmt.promote) {prev=stmtscontinueend

        if isCtrlExpr(stmt) and stmt.body then promoteCandidates(stmt.body)

    startloop:
        pc = promotionCandidate(stmt)
        if missing(pc)  ~ most likely
            prev = stmts
            skip
        end
        if pc == stmt
            ~ possible, less likely: stmt already at toplevel.
            ~ TODO: in this case, you still have to add the extra arg.
            prev = stmts
            skip
        end

        var pcClone ASTExpr = clone(pc)

        ~ 1. add a temp var to the scope
        tmpCount += 1
        var tmpvar = ASTVar {
            .name = "1p$tmpCount" ~newTmpVarName(tmpCount, 'p')
            .typeSpec = ASTTypeSpec {}
        }
        ~        tmpvar.typeSpec.typeType = .real64 ~ FIXME
        ~ TODO: setup tmpvar.typeSpec
        ~push(&scope.locals, item = tmpvar)
        scope.locals[end+1] = tmpvar

        ~ 2. change the original to an ident
        pc.kind = .identifierResolved
        pc.prec = 0
        pc.var = tmpvar

        ~ 3. insert the tmp var as an additional argument into the call

        if not pcClone.left
            pcClone.left = pc
        else if pcClone.left.kind != .opComma
            ~ single arg
            pcClone.left = ASTExpr {
            ~ TODO: really should have an astexpr ctor
                .kind = TokenKinds.opComma
                .prec = precedence(TokenKinds.opComma)
                .left = pcClone.left
                .right = pc
            }
            ~ pcClone.left = com
        else
            var argn ASTExpr = pcClone.left
            while argn.kind == .opComma and argn.right.kind == .opComma
                argn = argn.right
            end
            argn.right = ASTExpr {
            ~ TODO: really should have an astexpr ctor
                .kind = TokenKinds.opComma
                .prec = precedence(TokenKinds.opComma)
                .left = argn.right
                .right = pc
            }
~            argn.right = com
        end

        ~ 4. insert the promoted expr BEFORE the current stmt
        ~        PtrListAppend(prev ? &prev : &self.stmts, pcClone)
        ~        PtrList* tmp = prev.next
        ~ THIS SHOULD BE in PtrList as insertAfter method
        if not prev
            scope.stmts = fpPtrListWith(pcClone)
            scope.stmts.next = stmts
            prev = scope.stmts
        else
            prev.next = fpPtrListWith(pcClone)
            prev.next.next = stmts
            prev = prev.next
        end ~ List(ASTExpr)* insertionPos = prev ? prev.next : self.stmts
          ~  insertionPos
        ~  = insertionPos
        goto startloop ~ it will continue there if no more promotions are
                        ~ needed

        prev = stmts
    end
end


func generate(scope ASTScope, level Integer)
{
    for local = scope.locals ~for ASTVar*, local, scope.locals)
    if local.used
        generate(local, level = level, static = no)
        print()
    end ~ these will be declared at top and defined within the expr list

    for stmt in scope.stmts ~for ASTExpr*, stmt, scope.stmts)
    ~{
        if stmt.kind == .lineComment then skip

        if genLineNumbers then print("~line $stmt.line")
        var lineIndex = stmt.line - 1
        if genCoverage then print("Cov[$lineIndex]++")
        if genLineProfile then print("
            LprofTmp = getticks();
            Lprof[$lineIndex] += (LprofTmp-LprofLast)/100;
            LprofLast = LprofTmp;")
        end
        generate(stmt, level, yes, no, no)
        if not isCtrlExpr(stmt) and stmt.kind != .keywordReturn)
            print("")
        else
            print("")
        ~ convert this into a flag which is set in the resolution pass
        if throws(stmt)
            print("    if Err == ERRORTRACE) goto backtrace")
        end
    end
end


func genJson(tType ASTType)
{
    print('
        void $tType.nameJson(const $tType.name self, Integer nspc) {
            printf("{\n");
        ')
    ~ print("    print(\"\\\"Type\\\": \\\"%s\\\"\")\n", tType.name)
    ~ if tType.body.locals) print("    print(\",\\n\")\n")

    ~ TODO: move this part into its own fFunc so that subclasses can ask the
    ~ superclass to add in their fields inline
    for local as ASTVar in tType.body.locals
        if not local then skip
        print('    printf("%.*s\"$var.name\": ", nspc+4, Spaces)')
        var valueType Text = typeName(var.init)
        print('
            $valueTypeJson(self.$var.name, nspc+4);
            printf(\"')
        if vars.next then print(",")
    end
    print("    print(\"%%.*send\", nspc, Spaces)\n")
    print("end\nMAKEJsonWrap(%s)\n~MAKEJsonFile(%s)\n", tType.name,
        tType.name)
    ~ print("~define %sJson(x) { print(\"\\\"%%s\\\": \",~x) "
    ~        "%sJsonWrap(x)
    ~ end\n\n",
    ~     tType.name, tType.name)
end


func genJsonReader(tType ASTType)
end

let functionEntryStuffUNESCAPED = '
    ~ifndef NOSTACKCHECK
        STACKDEPTHUP
        // printf("%8lu %8lu\n",ScUsage, ScSize)
        if ScUsage >= ScSize) {
    ~ifdef DEBUG
        ScPrintAbove = ScDepth - BtLimit;
        print("\e[31mfatal: stack overflow at call depth %lu.\n    in %s\e[0m\n", ScDepth, sig);
        print("\e[90mBacktrace (innermost first):\n");
        if ScDepth > 2*BtLimit)
            print("    limited to %d outer and %d inner entries.\n", BtLimit, BtLimit);
            print("[%lu] \e[36m%s\n", ScDepth, callsite);
    ~else
            print("\e[31mfatal: stack  overflow at call depth %lu.\e[0m\n", ScDepth);
    ~endif
            DONE
        }
    ~endif
    '

let functionExitStuffUNESCAPED = '
    out = DEFAULTVALUE;
    assert(0);
    error:
    ~ifdef DEBUG
        eprintf("error: %s\n",Err);
    ~endif
    backtrace:
    ~ifdef DEBUG
        if ScDepth <= BtLimit || ScDepth > ScPrintAbove)
            print("\e[90m[%lu] \e[36m%s\n", ScDepth, callsite);
        else if ScDepth == ScPrintAbove)
            print("\e[90m... truncated ...\e[0m\n");
    ~endif
    done:
    ~ifndef NOSTACKCHECK
        STACKDEPTHDOWN
    ~endif
        out = DEFAULTVALUE;
    '

func printStackUsageDef(stackUsage Integer)
    print('
        ~ifdef DEBUG
        ~define MYSTACKUSAGE ($stackUsage$ + 6*sizeof(void*) + sizeof(char*))
        ~else
        ~define MYSTACKUSAGE ($stackUsage$ + 6*sizeof(void*))
        ~endif
        ')
end

func generate(tType ASTType, level Integer)
    if not tType.body or not tType.analysed then return
    var name Text = tType.name
    print('~define FIELDS$name$')
    for local as ASTVar in tType.body.locals
        generate(local, level=level+lStep, no)
    end

    print('

    struct $name$ {')

    if tType.super
        print("    FIELDS")
        generate(tType.super, level=level, other=no)
    end

    print('
        FIELDS$name$
        }

        static const char* $nameName$ = "$name$";
        static $name$ $nameAlloc$() {
            out = PoolAlloc(&gPool, sizeof(struct $name$));
        }
        static $name$ $nameInit$($name$ self) {')

    ~ for ASTVar*, var, tType.body.locals)
    ~     print("~define %s self.%s\n", var.name, var.name)
    for local as ASTVar in tType.body.locals
        print('~define $local.name$ self.$local.name$')
    end

    for stmt as ASTExpr in tType.body.stmts
        if not stmt or stmt.kind != .varAssign or not stmt.var.init then skip
        var ll = level + lStep
        print('$spaces@ll$$name$ = ')
        generate(stmt.var.init, 0, yes, no, no)

        if throws(stmt.var.init)
            print("    if Err == ERRORTRACE) out = missing;")
        end
    end

    for local as ASTVar in tType.body.locals do print('~undef {local.name}')

    print('
           out = self;
        }
            {name} {name.koiu}_new(
            ~ifdef DEBUG
                const char* callsite
            ~endif
        ) {==\\9igtr5}
        ~define DEFAULTVALUE missing
        ~ifdef DEBUG
func const char* sig = "{b64(name)}()"
        ~endif')

    ~ uglly uglly. therefore string interp is the only way
    print(
        '   out = self;
        }
            'name' 'upper(name)'New(
            ~ifdef DEBUG
                const char* callsite
            ~endif
        ) {
        ~define DEFAULTVALUE missing
        ~ifdef DEBUG
func const char* sig = "' name '()"
        ~endif')

    name .= 'wow'

    printStackUsageDef(48)
    print(functionEntryStuffUNESCAPED)
    print('
        $name$ ret = $nameAlloc$();
        $nameInit$(ret);
        if (Err == ERRORTRACE) goto backtrace;
        Err = missing;
        ~ifndef NOSTACKCHECK
            STACKDEPTHDOWN
        ~endif
        out = ret;')
    print(functionExitStuffUNESCAPED)
    print('
        ~undef DEFAULTVALUE
        ~undef MYSTACKUSAGE
        }
        ~define $name$_print(p) $name$_print_(p, STR(p))
        void $name$_print_($name$ self, const char* name) {
            printf("<$name$ \'%s\' at %p>", name, self)
        }')

    genJson(tType)
    genJsonReader(tType)
end

preferredRegexStyle := `
    [a-z] ~ starts with a lowercase letter only
    [A-Za-z0-9]* ~ followed by any alnum but NOT underscore
    (?= *\() ~ lookahead must be opening paren (whitespace ok before it)
    `

ASTType generateHeader(ASTType tType, Int level)

export function generateHeader(tType ASTType, level Int)
    check tType.body != nil ~ means declared funcs ~ BTW in jet if body is an
    ~ array it CANNOT be nil
    check not tType.isDecl
    check len(tType.body) > 0
    check tType.analysisDone or tType.analysisNotNeeded
    ~ you cant catch it all at compile time, but this will force the caller to
    ~ add an if(...) for this condition and not the callee!!!! yay
    ~ if you don't have a return keyword, fFunc writers will be forced to put
    ~ such checks

    var name String = tType.name
    check name != "" ~ this should be interpreted as a requires on tType.name!

    print('
        typedef struct $name* $name;
        struct $name;
        void $name.upper $name_alloc();
        void $name $name_init($name self);
        $name $name_new(
            ~ifdef DEBUG
                const char* callsite
            ~endif
            );
        DECLJsonWrap($name);
        DECLJsonFile($name);
        ~define $name_json(x) { printf("\"%s\": ", ~x); $name_json_wrap(x); }
        void $name_json(const $name self, int nspc)')

    ~ by allowing only ' as string delim, you can write code templates for
    ~ most other langs almost literally since they seem to use " for strs

    ~ You know that string interp is only allowed in literals, NOT in strings
    ~ read from somewhere! For that you have to explicitly do a replace().
end


generate(fFunc ASTFunc, level Integer)
{
    if not fFunc.body or not fFunc.analysed) out = ~ declares, default ctors

    ~ actual stack usage is higher due to stack protection, frame bookkeeping
    ~ ...
    Integer stackUsage = calcSizeUsage(fFunc)
    printStackUsageDef(stackUsage)

    print(
        "~define DEFAULTVALUE %s\n", getDefaultValueForType(fFunc.returnSpec))
    if not fFunc.isExported print("static void ")
    if fFunc.returnSpec
        generate(fFunc.returnSpec, level, no)
    else
        print("void")
    end
    print(" %s(", fFunc.selector)
    fpForeachn(ASTVar*, arg, args, fFunc.args)
    {
        generate(arg, level, yes)
        print(args.next ? ", " : "")
    end

    print("\n~ifdef DEBUG\n"
           "    %c const char* callsite "
           "\n~endif\n",
        ((fFunc.args and fFunc.args.item ? ',' : ' ')))

    ~ TODO: if flags.throws) print("const char** Err")
    print(") {")
    print("~ifdef DEBUG\n"
           "    function const char* sig = \"")
    print("%s%s(", fFunc.isStmt ? "" : "function ", fFunc.name)

    fpForeachn(ASTVar*, arg, args, fFunc.args)
    {
        gen(arg, level)
        print(args.next ? ", " : ")")
    end
    if fFunc.returnSpec) {
        print(" returns ")
        ASTTypeSpecGen(fFunc.returnSpec, level)
    end
    print("\"\n~endif")

    print(functionEntryStuffUNESCAPED)

    generate(fFunc.body, level + lStep)

    print(functionExitStuffUNESCAPED)
    print("end\n~undef DEFAULTVALUE")
    print("~undef MYSTACKUSAGE")
end


func generateHeader(fFunc ASTFunc, level Integer)
{
    if not fFunc.body or not fFunc.analysed) out =
    if not fFunc.isExported) print("function ")
    if fFunc.returnSpec) {
        ASTTypeSpecGenc(fFunc.returnSpec, level, no)
    end else {
        print("void")
    end
    print(" %s(", fFunc.selector)
    fpForeachn(ASTVar*, arg, args, fFunc.args)
    {
        generate(arg, level, yes)
        print(args.next ? ", " : "")
    end
    print("\n~ifdef DEBUG\n    %c const char* callsite "
           "\n~endif\n",
        ((fFunc.args and fFunc.args.item) ? ',' : ' '))
    print(")\n")
end

~~~~~~~~~~~~~~~~~~~~~~~~~~

func generate(tTest ASTTest)
{
    ~ TODO: should tests not out = BOOL?
    if not tTest.body out =
    print("\nstatic void test%s() {\n", tTest.name)
    generate(tTest.body, lStep)
    print("end")
end


func generate(
    expr as ASTExpr, level Integer, spacing YesOrNo, inFuncArgs YesOrNo, escStrings YesOrNo)
{
    ~ generally an expr is not split over several lines (but maybe in
    ~ rare cases). so level is not passed on to recursive calls.

    print("%.*s", level, spaces)
    switch (expr.kind) {
    case .number: {
        ls as Integer = strlen(expr.string)
        if expr.string[ls - 1] == 'i') {
            print("ComplexI*")
            expr.string[ls - 1] = 0
        end
        print("%s", expr.string)
    end break
    case .multiDotNumber, .identifier:
        print("%s", expr.string)
        break

    case .string:
        ~ TODO: parse vars inside, escape stuff, etc.
        print(escStrings ? "\\%s\\\"" : "%s\"", expr.string)
        break

    case .identifierResolved:
        print("%s", expr.var.name)
        break

    case .regex:
        ~ 'raw strings' or 'regexes'
        print("\"%s\"", expr.string + 1)
        break

    case .inline:
        ~ inline C code?
        print("%s", expr.string + 1)
        break

    case .lineComment:
        ~ TODO: skip  comments in generated code
        print("~ %s", expr.string)
        break

    case .functionCall:
        unreachable("unresolved call to %s\n", expr.string)
        assert(0)
        break

    case .functionCallResolved: {
        var tmp Text = expr.fFunc.selector

        var arg1 ASTExpr = expr.left
        const char* tmpc = ""
        if arg1) {
            if arg1.kind == .opComma) arg1 = arg1.left
            tmpc = CollectionTypeNativeName(arg1.collectionType)
        end
        print("%s%s", tmpc, tmp)
        if *tmp >= 'A' and *tmp <= 'Z' and not strchr(tmp, ''))
            print("New")
        print("(")

        if expr.left) generate(expr.left, 0, no, yes, escStrings)

        if not expr.fFunc.isDeclare) {
            print("\n~ifdef DEBUG\n"
                   "      %c \"./\" THISFILE \":%d:%d:\\e[0m ",
                expr.left ? ',' : ' ', expr.line, expr.col)
            gen(expr, 0, no, yes)
            print("\"\n"
                   "~endif\n        ")
        end
        print(")")
    end break

    case .subscript:
        assert(0)
        break

    case .subscriptResolved: {
        char* name = expr.var.name
        index as ASTExpr = expr.left
        assert(index)
        switch (index.kind) {
        case .number:
            ~ indexing with a single number
            ~ can be a -ve number
            print("ArrayGet%s(%s, %s)",
                cname(expr.var.typeSpec), name, index.string)
            break

        case .string, .regex:
            ~ indexing with single string or regex
            print("DictGetCString%s(%s, %s)",
                cname(expr.var.typeSpec), name, index.string)
            break

        case .opComma:
            ~ higher dimensions. validation etc. has been done by this
            ~ stage.

            ~ this is for cases like arr[2, 3, 4].
            print("Tensor%dDGet%s(%s, {", expr.var.typeSpec.dims,
                cname(expr.var.typeSpec), name)
            generate(index, 0, no, inFuncArgs, escStrings)
            print("end)")

            ~ TODO: cases like arr[2:3, 4:5, 1:end]
            ~ basically the idea is to generate getijk/getIJK/getIJk etc.
            ~ where a caps means range and lowercase means single number.
            ~ so arr[2:3, 4:5, 1:end] should generate `getIJK`,
            ~ arr[2:3, 4, 2:end] should generate `getIjK` and so on.
            ~ Those are then macros in the "runtime" that have for loops
            ~ for the ranges and nothing special for the single indices.
            ~ but they should be put into a tmpvar to avoid repeated eval.

            break

        case .opColon:
            ~ a single range.
            print("ArrayGetSlice%s(%s, ",
                ASTTypeSpecName(expr.var.typeSpec), name)
            generate(index, 0, no, inFuncArgs, escStrings)
            print(")")
            break
            ~ what about mixed cases, e.g. arr[2:3, 5, 3:end]
            ~ make this portion a recursive function then, or promote
            ~ all indexes to ranges first and then let opcomma handle it

        case .opEQ, .opLE, .opGE, .opGT, .opLT, .opNE, .keywordAnd, .keywordOr, .keywordNot:
            ~ indexing by a Boolean expression (filter)
            ~ by default this implies a copy, but certain funcs e.g. print
            ~ min max sum count etc. can be done in-place without a copy
            ~ since they are not mutating the array. That requires either
            ~ the user to call print(arr, filter = arr < 5) instead of
            ~ print(arr[arr < 5]), or the compiler to transform the second
            ~ into the first transparently.
            ~ Probably the .functionCall should check if its argument is
            ~ a .subscript with a Boolean index, and then tip the user
            ~ to call the optimised function instead (or just generate it).
            ~ For now, and in the absence of more context, this is a copy.
            ~ ArrayCopyFilter is implemented as a C macro for loop, as
            ~ are most other filtering-enabled functions on arrays.
            ~ TODO: be careful with the "template" style call here xx()()
            ~ TODO: actually I think arr[arr < 5] etc. should just be
            ~ promoted
            ~    and then the generation will follow the modified AST.
            ~    Don't handle this as a special case at the code generation
            ~    stage.
            print("ArrayCopyFilter%s(%s, ",
                ASTTypeSpecName(expr.var.typeSpec), name)
            generate(index, 0, no, inFuncArgs, escStrings)
            print(")")
            break

        default:
            assert(0)
            break
        end
        break
    end

    case .opAssign, .plusEq, .minusEq, .timesEq, .slashEq, .powerEq, .opModEq

        match expr.left.kind
        case .subscriptResolved:
            match expr.left.left.kind
            case .number, .string, .regex
                ~ TODO: astexprTypename should out = ArrayScalar or
                ~ Tensor2DScalar or DictStringScalar etc.
                var ttypeName = typeName(expr.left)
                var srepr = repr(expr.kind, spacing)
                print('
                $ttypeNameSet(
                    $expr.left.var.name,
                    $expr.left.left.string, srepr, ')
                generate(expr.right, 0, spacing, inFuncArgs, escStrings)
                print(")")

            case .opColon:
                print("%sSetSlice(%s, ", typeName(expr.left),
                    expr.left.var.name)
                generate(
                    expr.left.left, 0, spacing, inFuncArgs, escStrings)
                print(",%s, ", repr(expr.kind, spacing))
                generate(expr.right, 0, spacing, inFuncArgs, escStrings)
                print(")")

            case .opEQ, .opGE, .opNE, .opGT, .opLE, .opLT, .keywordAnd, .keywordOr, .keywordNot:
                print("%sSetFiltered(%s, ", typeName(expr.left),
                    expr.left.var.name)
                generate(
                    expr.left.left, 0, spacing, inFuncArgs, escStrings)
                print(",%s, ", repr(expr.kind, spacing))
                generate(expr.right, 0, spacing, inFuncArgs, escStrings)
                print(")")
                break

            case .opComma:
                ~ figure out the tType of each element
                ~ there should be a RangeND just like TensorND and SliceND
                ~ then you can just pass that to SetSlice
                break
            case .identifierResolved:
                ~ lookup the var tType. note that it need not be Number,
                ~ string, range etc. it could be an arbitrary object in
                ~ case you are indexing a Dict with keys of that tType.

            case .subscriptResolved:
                ~ arr[arr2[4]] etc.

            case .functionCallResolved:
                ~ arr[fFunc(x)]

            default:
                unreachable("%s\n", str[expr.left.kind])
                assert(0)
            end

        case .identifierResolved, .period:
            generate(expr.left, 0, spacing, inFuncArgs, escStrings)
            print(repr(expr.kind, spacing=spacing))
            generate(expr.right, 0, spacing, inFuncArgs, escStrings)

        case .identifier:
            check inFuncArgs
            generate(expr.right, 0, spacing, inFuncArgs, escStrings)
            ~ function call arg label, do not generate .left

        default:
            ~ error: not a valid lvalue
            ~ TODO: you should at some point e,g, during resolution check
            ~ for assignments to invalid lvalues and raise an error
            assert(0)
        end
        ~ if not inFuncArgs) {
        ~     generate(self.left, 0, spacing, inFuncArgs,
        ~     escStrings) print("%s", repr(.opAssign,
        ~     spacing))
        ~ end
        ~ generate(self.right, 0, spacing, inFuncArgs, escStrings)
        ~ check various types of lhs  here, eg arr[9:87] = 0,
        ~ map["uuyt"]="hello" etc.
        break

    case .arrayOpen:
        ~ TODO: send parent ASTExpr* as an arg to this function. Then
        ~ here do various things based on whether parent is a =,
        ~ funcCall, etc.
        print("mkarr(((%s[]) {", "double") ~ FIXME
        ~ TODO: MKARR should be different based on the CollectionType
        ~ of the var or arg in question, eg stack cArray, heap
        ~ allocated Array, etc.
        generate(expr.right, 0, spacing, inFuncArgs, escStrings)
        print("end)")
        print(", %d)", countCommaList(expr.right))

    case .opColon: ~ convert 3:4:5 to range(...)
                    ~ must do bounds check first!
        print(
            "%s(", expr.left.kind != .opColon ? "rangeTo" : "rangeToBy")
        if expr.left.kind == .opColon) {
            expr.left.kind = .opComma
            generate(expr.left, 0, no, inFuncArgs, escStrings)
            expr.left.kind = .opColon
        end else
            generate(expr.left, 0, no, inFuncArgs, escStrings)
        print(", ")
        generate(expr.right, 0, no, inFuncArgs, escStrings)
        print(")")
        break

    case .varAssign: ~ basically a .opAssign corresponding to a local
                      ~ var
        ~ var x as XYZ = abc... . becomes an ASTVar and an
        ~ ASTExpr (to keep location). Send it to ASTVar::gen.
        if expr.var.init != nil and expr.var.used
            print("$expr.var.name = ")
            generate(expr.var.init, 0, yes, inFuncArgs, escStrings)
        end
        break

    case .keywordElse:
        print("else {")
        if expr.body) generate(expr.body, level + lStep)
        print("$indent end", level, spaces)
        break

    case .keywordElif:
        print("else if ")
        generate(expr.left, 0, spacing, inFuncArgs, escStrings)
        print(") {")
        if expr.body then generate(expr.body, level + lStep)
        print("%.*send", level, spaces)

    case .keywordFor, .keywordIf:
        ~    case .keywordElif:
        ~    case .keywordElse, .keywordWhile:
        if expr.kind == .keywordFor)
            print("FOR(")
        else
            print("%s (", repr(expr.kind, yes))
        if expr.kind == .keywordFor) expr.left.kind = .opComma
        if expr.left)
            generate(expr.left, 0, spacing, inFuncArgs, escStrings)
        if expr.kind == .keywordFor) expr.left.kind = .opAssign
        print(") {")
        if expr.body) generate(expr.body, level + lStep)
        print("%.*send", level, spaces)
        break

    case .power:
        print("pow(")
        generate(expr.left, 0, no, inFuncArgs, escStrings)
        print(",")
        generate(expr.right, 0, no, inFuncArgs, escStrings)
        print(")")
        break

    case .keywordReturn:
        print("{Err = missing \n~ifndef NOSTACKCHECK\n    "
               "STACKDEPTHDOWN\n~endif\nreturn ")
        generate(expr.right, 0, spacing, inFuncArgs, escStrings)
        print("end\n")

    case .keywordCheck: {
        ~ TODO: need llhs and lrhs in case all 3 in 3way are exprs
        ~ e.g. check a+b < c+d < e+f
        checkExpr as ASTExpr = expr.right ~ now use checkExpr below
        lhsExpr as ASTExpr = checkExpr.left
        rhsExpr as ASTExpr = checkExpr.right
        print("{\n")
        if not checkExpr.unary) {
            print("%.*s%s Lhs = ", level, spaces, typeName(lhsExpr))
            generate(lhsExpr, 0, spacing, no, no)
            print("\n")
        end
        print("%.*s%s Rhs = ", level, spaces, typeName(rhsExpr))
        generate(rhsExpr, 0, spacing, no, no)
        print("\n")
        print("%.*sif not(", level, spaces)
        generate(checkExpr, 0, spacing, no, no)
        print(")) {\n")
        print("%.*sprintf(\"\\n\\n\e[31mruntime error:\e[0m check "
               "failed at "
               "\e[36m./%%s:%d:%d:\e[0m\\n    "
               "%%s\\n\\n\", THISFILE, \"",
            level + lStep, spaces, expr.line, expr.col + 6)
        gen(checkExpr, 0, spacing, yes)
        print("\")\n")
        print("~ifdef DEBUG\n%.*sprintf(\"\e[90mHere's some "
               "help:\e[0m\\n\")\n",
            level + lStep, spaces)

        genPrintVars(checkExpr, level + lStep)
        ~ the `printed` flag on all vars of the expr will be set
        ~ (genPrintVars uses this to avoid printing the same var
        ~ twice). This should be unset after every toplevel call to
        ~ genPrintVars.
        if not checkExpr.unary) {
            ~ dont print literals or arrays
            if lhsExpr.collectionType == C.none ~
                and lhsExpr.kind != .string ~
                and lhsExpr.kind != .number ~
                and lhsExpr.kind != .regex ~
                and lhsExpr.kind != .opLE ~
                and lhsExpr.kind != .opLT) {

                if lhsExpr.kind != .identifierResolved
                    or not lhsExpr.var.visited) {
                    print(
                        "%.*s%s", level + lStep, spaces, "print(\"    %s = ")
                    print("%s", TypeTypeFormat(lhsExpr.typeType, yes))
                    print("%s", "\\n\", \"")
                    gen(lhsExpr, 0, spacing, yes)
                    print("%s", "\", Lhs)\n")
                end
                ~ checks can't have .varAssign inside them
                ~ if )
                ~     lhsExpr.var.visited = yes
            end
        end
        if rhsExpr.collectionType == C.none ~
            and rhsExpr.kind != .string ~
            and rhsExpr.kind != .number ~
            and rhsExpr.kind != .regex) {
            if rhsExpr.kind != .identifierResolved
                or not rhsExpr.var.visited) {
                print("%.*s%s", level + lStep, spaces, "print(\"    %s = ")
                print("%s", TypeTypeFormat(rhsExpr.typeType, yes))
                print("%s", "\\n\", \"")
                gen(rhsExpr, 0, spacing, yes)
                print("%s", "\", Rhs)\n")
            end
        end

        unmarkVisited(checkExpr)

        print("%.*sprintf(\"\\n\")\n", level + lStep, spaces)
        print("%s",
            /*"~ifdef DEBUG\n"*/
            "        print(\"\\e[90mBacktrace (innermost "
            "first):\\n\")\n"
            "        if ScDepth > 2*BtLimit)\n        "
            "print(\"    limited to %d outer and %d inner "
            "entries.\\n\", "
            "BtLimit, BtLimit)\n"
            "        BACKTRACE\n    \n"
            "~else\n"
            "        eputs(\"(run in debug mode to get more info)\\n\") "
            "exit(1)\n"
            "~endif\n")
        print("\n%.*send\n", level, spaces)
        print("%.*send", level, spaces)
    end break

    case .period:
        generate(expr.left, 0, spacing, inFuncArgs, escStrings)
        print(".") ~ may be . if right is embedded and not a reference
        generate(expr.right, 0, spacing, inFuncArgs, escStrings)
        break

    case .opEQ, .opNE, .opGE, .opLE, .opGT, .opLT:
        if (expr.kind == .opLE or expr.kind == .opLT)
            and (expr.left.kind == .opLE or expr.left.kind == .opLT)) {
            print("%sCmp3way%s%s(", typeName(expr.left.right),
                ascrepr(expr.kind, no),
                ascrepr(expr.left.kind, no))
            generate(expr.left.left, 0, spacing, inFuncArgs, escStrings)
            print(", ")
            generate(expr.left.right, 0, spacing, inFuncArgs, escStrings)
            print(", ")
            generate(expr.right, 0, spacing, inFuncArgs, escStrings)
            print(")")
            break
        end else if expr.right.typeType == .string) {
            print("strCmp(%s, ", repr[expr.kind])
            generate(expr.left, 0, spacing, inFuncArgs, escStrings)
            print(", ")
            generate(expr.right, 0, spacing, inFuncArgs, escStrings)
            print(")")
            break
        end
        fallthrough default : if not expr.prec) break
        ~ not an operator, but this should be error if you reach here
        var leftBr YesOrNo
            = expr.left
            and expr.left.prec
            and expr.left.prec < expr.prec

        var rightBr YesOrNo =
            expr.right
            and expr.right.prec
            and expr.right.kind != .keywordReturn
            and expr.right.prec < expr.prec
        ~ found in 'or out ='

        char lpo = '('
        char lpc = ')'
        if leftBr) putc(lpo, stdout)
        if expr.left)
            generate(expr.left, 0,
                spacing and not leftBr and expr.kind != .opColon, inFuncArgs,
                escStrings)
        if leftBr) putc(lpc, stdout)

        if expr.kind == .arrayOpen)
            putc('{', stdout)
        else
            print("%s", repr(expr.kind, spacing))

        char rpo = '('
        char rpc = ')'
        if rightBr) putc(rpo, stdout)
        if expr.right)
            generate(expr.right, 0,
                spacing and not rightBr and expr.kind != .opColon, inFuncArgs,
                escStrings)
        if rightBr) putc(rpc, stdout)

        if expr.kind == .arrayOpen) putc('end', stdout)
    end
end

~ WARNING: DO NOT USE THESE STRINGS WITH PRINTF(...) USE PUTS(...).
func const char* coverageFunc[] = { ~
    "function fpCoverageReport() { /* unused */ end",
    "function fpCoverageReport() {\n"
    "    Integer count=0,l=NUMLINES\n"
    "    while(--l>0) count+=!!Cov[l]\n"
    "    print(\"coverage: %d/%d lines = %.2f%%\\n\","
    "        count, NUMLINES, count*100.0/NUMLINES)\n"
    "end"
end
~ WARNING: DO NOT USE THESE STRINGS WITH PRINTF(...) USE PUTS(...).
func const char* lineProfileFunc[] = {
    ~
    "function fpLineprofileReport() { /* unused */ end\n"
    "function fpLineprofileBegin() { /* unused */ end\n",
    "function fpLineprofileReport() {\n"
    ~ "    print(\"profiler: %llu cycles\\n\","
    ~ "        Lprof[NUMLINES-1]-Lprof[0])\n"
    "    FILE* fd = fopen(\".\" THISFILE \"r\", \"w\")\n"
    ~ "    for (Integer i=1 i<NUMLINES i++)\n"
    ~ "        if 0== Lprof[i]) Lprof[i] = Lprof[i-1]\n"
    ~ "    for (Integer i=NUMLINES-1 i>0 i--) Lprof[i] -= Lprof[i-1]\n"
    "    ticks sum=0 for (Integer i=0 i<NUMLINES i++) sum += Lprof[i]\n"
    "    for (Integer i=0 i<NUMLINES i++) {\n"
    "        double pct = Lprof[i] * 100.0 / sum\n"
    "        if pct>1.0)"
    "            fprintf(fd,\" %8.1f%% |\\n\", pct)\n"
    "        else if pct == 0.0)"
    "            fprintf(fd,\"           |\\n\")\n"
    "        else"
    "            fprintf(fd,\"         ~ |\\n\")\n"
    "    end\n"
    "    fclose(fd)\n"
    "    system(\"paste -d ' ' .\" THISFILE \"r \" THISFILE \" > \" "
    "THISFILE "
    "\"r\" )"
    "end\n"
    "function fpLineprofileBegin() {LprofLast=getticks()end\n"
end

~ TODO: why do you need to pass level here?
func generate(module ASTModule, level Integer)
    for imp as ASTImport in module.imports do generate(imp, level=level)

    print("")

    for tType as ASTType in module.types do generateHeader(tType, level=level)
    for fFunc as ASTFunc in module.funcs do generateHeader(fFunc, level=level)

    ~ I think you should still have elemental-by-default funcs.
    generateHeader(module.types[:], level=level)
    generateHeader(module.funcs[:], level=level)
    ~ if a fFunc is defined for an array, then it doesnt need to be elemental
    ~ since there are no arrays of arrays. so you cant e.g. pass a 2D array
    ~ and run a 1D array-fFunc on each column/row. if there are no arrays of arrays
    ~ then what about funcs returning arrays?
    ~ OK ONLY SCALAR-VALUED or no-return and SCALAR-ARG funcs can be elemental!
    ~ and are by default. UNLESS YOU OVERRIDE the fFunc for arrays of that type

    for tType as ASTType in module.types do generate(tType, level=level)
    for fFunc as ASTFunc in module.funcs do generate(fFunc, level=level)
    for imp as ASTImport in module.imports do undefc(imp)

    print(coverageFunc[genCoverage])
    print(lineProfileFunc[genLineProfile])
end

func genTests(module ASTModule, level Integer)
    ASTModuleGenc(module, level)
    for ASTTest*, tTest, module.tests) ASTTestGenc(tTest)
    ~ generate a fFunc that main will call
    print("\nvoid testsRun%s() {\n", module.name)
    for ASTTest*, tTest, module.tests)
        print("    test%s()\n", tTest.name)
    print("end")
end



type Y
    var z = 9
end

type X
    var y = Y()
end

func start()
    var name = "SP"
    var x = X()
    print("Hello $x.y.z")
end

...

int main() {
    char* name = "SP";
    printf("Hello %s", name);
}





print("static void* $type.name__memberNamed($type.name self, const char* name) {")





























